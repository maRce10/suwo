request_obj,
term = species
)
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
response <- httr2::req_perform(request_obj)
# check if request succeeded
if (httr2::resp_status(response) >= 400) {
if (verbose) {
.message(
text = paste0(
"Wikiaves query request failed: ",
httr2::resp_status_desc(response)
),
as = "failure"
)
}
return(invisible(NULL))
}
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
if (length(get_ids) == 0) {
if (verbose) {
.message("Search species not found", as = "failure")
}
return(invisible(NULL))
}
get_ids$total_registers <- vapply(
seq_len(nrow(get_ids)),
function(u) {
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getRegistrosJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
tm = wiki_format,
t = "s",
s = get_ids$id[u],
o = "mp",
p = 1
)
request_obj <-
httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
request_obj <- httr2::req_error(request_obj, is_error = function(resp) {
FALSE
})
response <- try(httr2::req_perform(request_obj), silent = TRUE)
# if fail request return -9999
if (.is_error(response)) {
return(-999)
}
# check if request succeeded
if (httr2::resp_is_error(response)) {
return(-999)
}
content <- httr2::resp_body_json(response)
as.numeric(content$registros$total)
},
numeric(1)
)
# let user gracefully know error when downloading metadata
if (
any(vapply(
get_ids$total_registers,
function(x) x == -999,
FUN.VALUE = logical(1)
))
) {
if (verbose) {
.message(text = "Metadata could not be downloaded", as = "failure")
}
return(invisible(NULL))
}
if (sum(get_ids$total_registers) == 0) {
if (verbose) {
.message(text = "No matching records found", as = "failure")
}
return(invisible(NULL))
}
# get number of pages (20 is the default number of registers per page)
get_ids$pages <- ceiling(get_ids$total_registers / 20)
# remove those rows with no pages
# (only needed when many species are returned)
get_ids <- get_ids[get_ids$pages > 0, ]
id_by_page_list <- lapply(seq_len(nrow(get_ids)), function(x) {
X <- get_ids[x, ]
data.frame(id = X$id, page = 1:X$pages)
})
id_by_page_df <- do.call(rbind, id_by_page_list)
# search recs in wikiaves (results are returned in pages with 500
# recordings each)
if (verbose) {
.message(n = get_ids$total_registers, as = "success")
}
get_ids$total_registers
get_ids$total_registers[1]
source("~/Dropbox/R_package_testing/suwo/R/query_wikiaves.R")
query_wikiaves(species = 'Piranga flava', format = "sound")
df1 <- try(
query_wikiaves(species = 'Piranga flava', format = "sound"),
silent = TRUE
)
nrow(df1)
species = 'Piranga flava'
check_results <- .check_arguments(
fun = "query_wikiaves",
args = list(
species = species,
format = format,
cores = cores,
pb = pb,
verbose = verbose,
all_data = all_data,
raw_data = raw_data
)
)
# report errors
checkmate::reportAssertions(check_results)
# Use the unified connection checker
if (!.checkconnection(verb = verbose, service = "wikiaves")) {
return(invisible(NULL))
}
# assign a value to format
format <- rlang::arg_match(format, values = c("image", "sound"))
wiki_format <- switch(format, sound = "s", image = "f")
# initialize search with user agent
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getTaxonsJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
term = species
)
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
response <- httr2::req_perform(request_obj)
# check if request succeeded
if (httr2::resp_status(response) >= 400) {
if (verbose) {
.message(
text = paste0(
"Wikiaves query request failed: ",
httr2::resp_status_desc(response)
),
as = "failure"
)
}
return(invisible(NULL))
}
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
if (length(get_ids) == 0) {
if (verbose) {
.message("Search species not found", as = "failure")
}
return(invisible(NULL))
}
get_ids$total_registers <- vapply(
seq_len(nrow(get_ids)),
function(u) {
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getRegistrosJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
tm = wiki_format,
t = "s",
s = get_ids$id[u],
o = "mp",
p = 1
)
request_obj <-
httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
request_obj <- httr2::req_error(request_obj, is_error = function(resp) {
FALSE
})
response <- try(httr2::req_perform(request_obj), silent = TRUE)
# if fail request return -9999
if (.is_error(response)) {
return(-999)
}
# check if request succeeded
if (httr2::resp_is_error(response)) {
return(-999)
}
content <- httr2::resp_body_json(response)
as.numeric(content$registros$total)
},
numeric(1)
)
# let user gracefully know error when downloading metadata
if (
any(vapply(
get_ids$total_registers,
function(x) x == -999,
FUN.VALUE = logical(1)
))
) {
if (verbose) {
.message(text = "Metadata could not be downloaded", as = "failure")
}
return(invisible(NULL))
}
if (sum(get_ids$total_registers) == 0) {
if (verbose) {
.message(text = "No matching records found", as = "failure")
}
return(invisible(NULL))
}
# get number of pages (20 is the default number of registers per page)
get_ids$pages <- ceiling(get_ids$total_registers / 20)
# remove those rows with no pages
# (only needed when many species are returned)
get_ids <- get_ids[get_ids$pages > 0, ]
id_by_page_list <- lapply(seq_len(nrow(get_ids)), function(x) {
X <- get_ids[x, ]
data.frame(id = X$id, page = 1:X$pages)
})
id_by_page_df <- do.call(rbind, id_by_page_list)
# search recs in wikiaves (results are returned in pages with 500
# recordings each)
if (verbose) {
.message(n = get_ids$total_registers[1], as = "success")
}
get_ids
species = 'Piranga flava'
##  argument checking
check_results <- .check_arguments(
fun = "query_wikiaves",
args = list(
species = species,
format = format,
cores = cores,
pb = pb,
verbose = verbose,
all_data = all_data,
raw_data = raw_data
)
)
# report errors
checkmate::reportAssertions(check_results)
# Use the unified connection checker
if (!.checkconnection(verb = verbose, service = "wikiaves")) {
return(invisible(NULL))
}
# assign a value to format
format <- rlang::arg_match(format, values = c("image", "sound"))
wiki_format <- switch(format, sound = "s", image = "f")
# initialize search with user agent
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getTaxonsJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
term = species
)
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
response <- httr2::req_perform(request_obj)
# check if request succeeded
if (httr2::resp_status(response) >= 400) {
if (verbose) {
.message(
text = paste0(
"Wikiaves query request failed: ",
httr2::resp_status_desc(response)
),
as = "failure"
)
}
return(invisible(NULL))
}
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
get_ids
species
# initialize search with user agent
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getTaxonsJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
term = species
)
request_obj
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
request_obj
response <- httr2::req_perform(request_obj)
response
species
species <- "Piranga"
# initialize search with user agent
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getTaxonsJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
term = species
)
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
response <- httr2::req_perform(request_obj)
response
# check if request succeeded
if (httr2::resp_status(response) >= 400) {
if (verbose) {
.message(
text = paste0(
"Wikiaves query request failed: ",
httr2::resp_status_desc(response)
),
as = "failure"
)
}
return(invisible(NULL))
}
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
get_ids
species = 'Piranga flava'
# report errors
checkmate::reportAssertions(check_results)
# Use the unified connection checker
if (!.checkconnection(verb = verbose, service = "wikiaves")) {
return(invisible(NULL))
}
# assign a value to format
format <- rlang::arg_match(format, values = c("image", "sound"))
wiki_format <- switch(format, sound = "s", image = "f")
# initialize search with user agent
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getTaxonsJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
term = species
)
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
response <- httr2::req_perform(request_obj)
# check if request succeeded
if (httr2::resp_status(response) >= 400) {
if (verbose) {
.message(
text = paste0(
"Wikiaves query request failed: ",
httr2::resp_status_desc(response)
),
as = "failure"
)
}
return(invisible(NULL))
}
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
get_ids
get_ids$total_registers
get_ids
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
nrow(get_ids)
# do exact matching for species name
get_ids <- get_ids[
trimws(tolower(get_ids$label)) ==
trimws(tolower(species)),
]
get_ids
source("~/Dropbox/R_package_testing/suwo/R/query_wikiaves.R")
query_wikiaves(species = 'Glaucis dohrnii', format = "sound")
query_wikiaves(species = 'Piranga flava', format = "sound")
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
install.packages("getPass")
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
run.all()
options(verbose = TRUE)
devtools::test()
install.packages("pkgload")
install.packages("pkgload")
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
run.all()
options(verbose = TRUE)
devtools::test()
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
query_wikiaves(species = 'asdasdasd', format = "image")
species = 'asdasdasd'
check_results <- .check_arguments(
fun = "query_wikiaves",
args = list(
species = species,
format = format,
cores = cores,
pb = pb,
verbose = verbose,
all_data = all_data,
raw_data = raw_data
)
)
# report errors
checkmate::reportAssertions(check_results)
# Use the unified connection checker
if (!.checkconnection(verb = verbose, service = "wikiaves")) {
return(invisible(NULL))
}
# assign a value to format
format <- rlang::arg_match(format, values = c("image", "sound"))
wiki_format <- switch(format, sound = "s", image = "f")
# initialize search with user agent
request_obj <- httr2::request(
"https://www.wikiaves.com.br/getTaxonsJSON.php"
)
request_obj <- httr2::req_url_query(
request_obj,
term = species
)
request_obj <- httr2::req_user_agent(
request_obj,
"suwo (https://github.com/maRce10/suwo)"
)
response <- httr2::req_perform(request_obj)
# check if request succeeded
if (httr2::resp_status(response) >= 400) {
if (verbose) {
.message(
text = paste0(
"Wikiaves query request failed: ",
httr2::resp_status_desc(response)
),
as = "failure"
)
}
return(invisible(NULL))
}
get_ids <- httr2::resp_body_json(
response,
check_type = FALSE,
simplifyVector = TRUE,
simplifyDataFrame = TRUE
)
# do exact matching for species name
get_ids <- get_ids[
trimws(tolower(get_ids$label)) ==
trimws(tolower(species)),
]
get_ids$label
get_ids
nrow(get_ids)
length(get_ids)
length(cars)
class(cars)
dim(cars)
source("~/Dropbox/R_package_testing/suwo/R/query_wikiaves.R")
query_wikiaves(species = 'asdasdasd', format = "image")
test_that("no result", {
skip_on_cran()
skip_if_offline()
expect_null(query_wikiaves(species = 'asdasdasd', format = "image"))
})
a <- query_wikiaves(species = 'asdasdasd', format = "image")
a
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
