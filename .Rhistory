# create a 6 pannel plot of the downloaded images
opar <- par(mfrow = c(2, 3), mar = c(1, 1, 2, 1))
for (i in 1:6) {
img <- jpeg::readJPEG(file.path(out_folder, dhol_files$downloaded_file_name[i]))
plot(
1:2,
type = 'n',
axes = FALSE
)
graphics::rasterImage(img, 1, 1, 2, 2)
title(main = paste(
substr(dhol_files$country[i], start = 1, stop = 14),
dhol_files$date[i],
sep = "\n"
))
}
dev.off()
# reset par
par(opar)
covr::file_coverage(
source_files = "./R/query_macaulay.R",
test_files = "./tests/testthat/test_query_macaulay.R")
rlang::last_trace()
devtools::install()
# Execute the code from the vignette
knitr::knit("vignettes/suwo.Rmd.orig", output = "vignettes/suwo.Rmd")
devtools::install()
# Execute the code from the vignette
knitr::knit("vignettes/suwo.Rmd.orig", output = "vignettes/suwo.Rmd")
df1 <- try(
query_wikiaves(
species = 'Glaucis dohrnii',
format = "sound",
all_data = FALSE
),
silent = TRUE
)
expected_col_names <- suwo:::.format_query_output(only_basic_columns = T)
expected_col_names
query_col_names
query_col_names %in% expected_col_names
all(query_col_names %in% expected_col_names)
all(expected_col_names %in% query_col_names)
expected_col_names
query_col_names
df1
nrow(df1)
test_that("test all_data FALSE", {
skip_on_cran()
skip_if_offline()
df1 <- try(
query_wikiaves(
species = 'Glaucis dohrnii',
format = "sound",
all_data = FALSE
),
silent = TRUE
)
# skip_if(suwo:::.is_error(df1))
#
#   expected_col_names <- suwo:::.format_query_output(only_basic_columns = T)
#
#   query_col_names <- colnames(df1)
#
#   expect_true(
#     all(query_col_names %in% expected_col_names) &
#       all(expected_col_names %in% query_col_names),
#     info = "Column names do not match the expected names"
#   )
expect_equal(nrow(df1), 36)
})
library(testthat)
test_that("test all_data FALSE", {
skip_on_cran()
skip_if_offline()
df1 <- try(
query_wikiaves(
species = 'Glaucis dohrnii',
format = "sound",
all_data = FALSE
),
silent = TRUE
)
# skip_if(suwo:::.is_error(df1))
#
#   expected_col_names <- suwo:::.format_query_output(only_basic_columns = T)
#
#   query_col_names <- colnames(df1)
#
#   expect_true(
#     all(query_col_names %in% expected_col_names) &
#       all(expected_col_names %in% query_col_names),
#     info = "Column names do not match the expected names"
#   )
expect_equal(nrow(df1), 36)
})
#run document twice
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
load("~/Dropbox/R_package_testing/suwo/R/sysdata.rda")
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
devtools::document(".")
devtools::check(document = TRUE, run_dont_test = TRUE, vignettes = TRUE, manual = TRUE)
pkgcheck::pkgcheck()
lintr::lint_package(linters = list(lintr::line_length_linter()))
source("~/Dropbox/R_package_testing/suwo/R/query_macaulay.R")
# run internals
run_ohun_int <- function(){
out <- lapply(list.files(pattern = "ohun_int", path = "./R", full.names = T), source)}
# open working directory
open.wd <- function() system(paste("nautilus", getwd()), show.output.on.console = F)
#open function in rstudio
open.fun <- function(fun) system(paste("rstudio", file.path("./R", paste0(fun, ".R"))))
# run default arguments in a warbleR function
run.def.args <- function(fun = NULL){
#list functions in package
rfiles <- list.files(pattern = ".R", path = "./R", full.names = T)
# select target function file
funfile <- rfiles[gsub(".R", "", basename(rfiles)) == fun]
x <- readLines(funfile, warn = F)
st <- grep('@usage', x, fixed = T)
en <- grep('@param', x, fixed = T)[1]
x <- paste(x[st:(en-1)], collapse = " ")
x <- gsub("usage|\\@|\\#\\'", "", x)
b <- gregexpr(pattern ='\\(|\\)',x)[1][[1]]
x <- substr(x, start = b[1] + 1, stop = b[length(b)] - 1)
spltx <- strsplit(x, "\\,")[[1]]
sl <- vector()
y = 1
while(y <= length(spltx))
{
w <- spltx[y]
z <- 1
if(grepl('\\(', spltx[y]))
{z  <- 0
while(!grepl('\\)', w))
{
z <- z+ 1
w <- paste(w, ",", spltx[y + z], collapse = "")
}
z <- z + 1
}
y = y + z
sl[length(sl) + 1] <- w
}
sl <- sl[sl != "X"]
return(sl)
}
# run it like this:
# for(i in run.def.args("dfts")) try(eval(parse(text = i)), silent = T)
# remove sound files and or image files
rm.sf <- function() unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.flac$|\\.mp3$|\\.wac$", ignore.case = T, full.names = TRUE))
rm.sf.img <- function(mp3 = TRUE) {if(mp3)
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.flac$|\\.mp3$|\\.wac$|\\.tiff$|\\.jpeg$|\\.png$", ignore.case = T, full.names = TRUE)) else
unlink(list.files(path = tempdir(), pattern = "\\.wav$|\\.flac$|\\.wac$|\\.tiff$|\\.jpeg$|\\.png$", ignore.case = T, full.names = TRUE))}
rm.img <- function() unlink(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$|\\.png$|\\.pdf$", ignore.case = T, full.names = TRUE))
#open latest image
last.img <- function() system(paste("eog", list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.tiff$|\\.jpeg$", ignore.case = T, full.names = TRUE)))]
))
#open pdf
last.pdf <- function() system(paste("xdg-open", list.files(path = tempdir(), pattern = "\\.pdf$", ignore.case = T, full.names = TRUE)[which.max(file.mtime(list.files(path = tempdir(), pattern = "\\.pdf", ignore.case = T, full.names = TRUE)))]
))
#find text in functions
find.text <- function(pattern, fun.only = FALSE, path = "./R", ignore.case = TRUE, file.ext = "\\.R$|\\.Rmd$", recursive = TRUE)
{
rfiles <- list.files(pattern = file.ext, path = path, full.names = T, all.files = T, ignore.case = ignore.case, recursive = recursive)
#check where a word is found in each function an return the name of function where it was found and the time
res <- NULL
w <- 1
for(f in rfiles){
x <- readLines(f)
y <- grep(pattern, x, fixed = T, value = T, ignore.case = ignore.case)
if(length(y)>0 & !fun.only) {
print(gsub(pattern = "\\.R", "", (basename(f))))
for(i in y) print(i)
}
if(length(y)>0 & fun.only) res[w] <- gsub(pattern = "\\.R", "", (basename(f)))
# options(nwarnings = 0)
w = w + 1
}
if(fun.only)
{res <- res[!is.na(res)]
return(res)}
}
#replace text
repl.text <- function(pattern, repl, path = "./R", ignore.case = T, file.ext = "\\.R$|\\.Rmd$", recursive = TRUE){
rfiles <- list.files(pattern =file.ext, path = path, full.names = T, all.files = T, ignore.case = ignore.case, recursive = recursive)
for(f in rfiles){
#find and replace
x <- readLines(f)
y <- gsub(pattern, repl, x, fixed = T, ignore.case = ignore.case)
cat(y, file=f, sep="\n")
#reread
x <- readLines(f)
w <- grep(repl, x, fixed = T, value = T, ignore.case = T)
if(length(w)>0) {
print(f)
for(i in w) print(i)
}
}
}
#find functions with specific arguments
find.arg <- function(arg1, arg2 = NULL){
rfiles <- list.files(pattern = "\\.R$", path = "./R", full.names = T, all.files = T)
funs <- gsub(pattern = "\\.R", "", (basename(rfiles)))
funs <-grep("zzz|data|package", funs, invert = T, value = T)
l1 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg1, a))) return(x)
}      ))
if(!is.null(arg2))
{l2 <- unlist(lapply(funs, function(x)
{  a <-  try(run.def.args(x), silent = T)
if(any(grep(arg2, a))) return(x)
}      ))
res <- intersect(l1, l2)
} else res <- l1
return(res)
}
# run default arguments
run.def.args2 <-function(FUN)
{
fm <- formals(FUN)
fm <- fm[sapply(fm, length) > 0 | sapply(fm, is.null)]
fm <- lapply(1:length(fm), function(x) paste(names(fm)[x], "=", fm[x]))
for(i in fm) try(eval(parse(text = i)), silent = T)
}
#find functions with specific arguments and text
find.arg.text <- function(arg1, arg2 = NULL, pattern) {
f1 <- find.text(pattern = pattern, fun.only = T)
f2 <- find.arg(arg1 = arg1, arg2 = arg2)
return(intersect(f1, f2))
}
#bid data set
big.seltab <- function(X, nrow = 100){
Y <- X[rep(1:nrow(X), ceiling(nrow/nrow(X)))[1:nrow],]
Y$selec <- 1:nrow(Y)
if(is_selection_table(Y) | is_extended_selection_table(Y))
attr(Y, "check.results") <- attr(X, "check.results")[rep(1:nrow(attr(X, "check.results")), ceiling(nrow/nrow(attr(X, "check.results"))))[1:nrow],]
attr(Y, "check.results")$selec <- 1:nrow(Y)
return(Y)
}
#write all wav files in lbh_selec_table
write.sound.files <- function(path = tempdir(), extensible = T, other.formats = FALSE, simulated = FALSE){
# setwd(path)
data(lbh1, package = "ohun")
data(lbh2, package = "ohun")
tuneR::writeWave(lbh1, file.path(tempdir(),  "lbh1.wav"), extensible = extensible) #save sound files
tuneR::writeWave(lbh2, file.path(tempdir(),  "lbh2.wav"), extensible = extensible) #save sound files
if (simulated){
# Creating vector for duration
durs <- rep(c(0.3, 1), 5)
# Creating simulated song
set.seed(12)
simulated_1 <- warbleR::simulate_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, harms = 1, bgn = 0.1, path = tempdir(), file.name = "simulated_1", selec.table = TRUE, shape = "cos", fin = 0.3, fout = 0.35, samp.rate = 18)
sim_2 <- sim_songs(n = 10, durs = durs, freqs = 5, sig2 = 0.01, gaps = 0.5, harms = 1, bgn = 0.1, path = tempdir(), file.name = "simulated_2", selec.table = TRUE, shape = "cos", fin = 0.3, fout = 0.35, samp.rate = 18, am.amps = c(1, 2, 3, 2, 0.1, 2, 3, 3, 2, 1))
sel_tab2 <- sel_tab1 <- simulated_1$selec.table
sel_tab2$sound.files <- gsub("_1", "_2", sel_tab2$sound.files)
sel_tab <- rbind(sel_tab1, sel_tab2)
return(sel_tab)
}
# if (other.formats){
#   file.copy(from = system.file("extdata", "recording_20170716_230503.wac", package = "bioacoustics"), to = file.path(tempdir(), "recording_20170716_230503.wac"))
#
# file.copy(from = "../Phae.long4.mp3", to = file.path(tempdir(),  "Phae.long4.mp3"))
#
#   file.copy(from = file.path(tempdir(), "Phae.long1.wav"), to = file.path(tempdir(), "Phae.long5.wav"))
#
# wav2flac(file.path(tempdir(), "Phae.long5.wav"))
#
# if (selection.table){
#
#   lbh_selec_table$sound.files <- as.character(lbh_selec_table$sound.files)
#
#   sub_tab <- lbh_selec_table[lbh_selec_table$sound.files %in% c("Phae.long1.wav", "Phae.long4.wav"), 1:7]
#
#   sub_tab$sound.files[sub_tab$sound.files == "Phae.long1.wav"] <- "Phae.long5.flac"
#
#     sub_tab$sound.files[sub_tab$sound.files == "Phae.long4.wav"] <- "Phae.long4.mp3"
#
#     # fix times
#      sub_tab$start[sub_tab$sound.files == "Phae.long4.mp3"] <- c(0.2085945, 1.5950019, 2.3057996)
#
#      sub_tab$end[sub_tab$sound.files == "Phae.long4.mp3"] <- c(0.3528653, 1.7287163, 2.4289576)
#
#
#     sub_tab <- rbind(sub_tab, data.frame(sound.files = "recording_20170716_230503.wac", channel = 1, selec = 1, start = 0.1, end = 0.3, bottom.freq = 2, top.freq = 10))
#
#     sub_tab <- rbind(sub_tab, lbh_selec_table[, 1:7])
#
#     sub_tab$format <-ifelse(grepl("flac$", sub_tab$sound.files), "flac", ifelse(grepl("mp3$", sub_tab$sound.files), "mp3", "wav"))
#
#
#     return(sub_tab)
# } else return(NULL)
# }
}
# run all warbleR fuctions
run.all <- function() invisible(lapply(list.files(pattern = "\\.R", path = "./R", full.names = T, all.files = T), function(x) source(x)))
# run.all()
list.selection.table <- function(lbh_selec_table, path = tempdir())
{
crr.dr <- getwd()
on.exit(setwd(crr.dr))
if(!is.null(path)) setwd(path)
Xlist <- list()
Xlist$Xdf <- lbh_selec_table
Xlist$Xst <- selection_table(lbh_selec_table)
Xlist$Xest <- selection_table(lbh_selec_table, extended = T, confirm.extended = F)
lbh_selec_table$song <- as.numeric(lbh_selec_table$sound.files)
Xlist$Xestbs <- selection_table(X = lbh_selec_table, extended = T, by.song = "song", confirm.extended = F)
names(Xlist) <- c("DATA.FRAME", "SELECTION_TABLE", "EXTENDED_SELECTION_TABLE", "by.song.EXTENDED_SELECTION_TABLE")
return(Xlist)
}
bi_mats <- function(X, labels) {
# create empty matrix to store memebership matrix
mat <- matrix(nrow = ncol(X), ncol = ncol(X))
# add labels to row and col names
rownames(mat) <- colnames(mat) <- labels
# add 0 if same lek and 1 if else
out <- lapply(1:(length(labels) - 1), function(i){
sapply((i + 1):length(labels), function(j)
if (labels[i] == labels[j]) 0 else 1)
})
# add to mat
mat[lower.tri(mat)] <- unlist(out)
# retunr as distance matrix
return(as.dist(mat))
}
plot_detection <- function(reference, detection, lwd = 90, sep = 1, labels = detection$selec){
if (!is.null(detection$detection.class)){
labels <- ifelse(detection$detection.class == "true.positive", "\nTP", ifelse(detection$detection.class == "false.positive", "\nFP", ifelse(detection$detection.class == "false.negative", "\nFN", ifelse(detection$detection.class == "true.positive (split)", "\nTPs", ifelse(detection$detection.class == "true.positive (merged)", "\nTPm", ifelse(detection$detection.class == "negative (split)", "\nNs", ifelse(detection$detection.class == "negative (merged)", "\nNm", ifelse(detection$detection.class == "negative (split/merged)", "\nNsm", "\nTPsm"))))))))
detection$labels <- paste0(detection$selec, labels)
} else detection$labels <- detection$selec
old_par <- par()
old_par <- old_par[!names(old_par) %in%  c("cin", "cra", "csi", "cxy", "din", "page")]
on.exit(par(old_par))
par(mar = rep(0, 4))
n_sound.files <- length(unique(c(reference$sound.files, detection$sound.files)))
if (n_sound.files > 1)
par(mfrow = c(n_sound.files, 1))
for (e in unique(c(detection$sound.files, reference$sound.files))){
sub_detec <- detection[detection$sound.files == e, ]
sub_ref <- reference[reference$sound.files == e, ]
plot(x = range(c(sub_detec$start, sub_detec$end, sub_ref$start, sub_ref$end)), y = c(-1, 1), col = "white", pch = 21, yaxt = "n", ylab = "", xaxt = "n", xlab = "")
# plot references first
if (nrow(sub_ref) > 0)
for (i in 1:nrow(sub_ref)){
segments(
x0 = sub_ref$start[i],
x1 = sub_ref$end[i],
y0 = sep / -2,
y1 = sep / -2,
lwd = lwd,
col = viridis::magma(10, alpha = 0.4)[3],
lend = 1
)
text(x = (sub_ref$end[i] + sub_ref$start[i]) / 2, y = sep / -2, labels = i, col = "white")
}
# add detections
if (nrow(sub_detec) > 0)
for (i in 1:nrow(sub_detec)){
segments(
x0 = sub_detec$start[i],
x1 = sub_detec$end[i],
y0 = sep / 2,
y1 = sep / 2,
lwd = lwd,
col = viridis::magma(10, alpha = 0.4)[7],
lend = 1
)
text(x = (sub_detec$end[i] + sub_detec$start[i]) / 2, y = sep / 2, labels = sub_detec$labels[i])
}
}
}
### simulate annotation tables
# cannot have duration shorter than 2
sim_annotation <- function(n = 10, n.sound.files = 1){
sims_l <- lapply(1:n.sound.files, function(x){
possible_start <- seq(0, 98, 2)
sim_ref <- data.frame(sound.files = paste0(x, ".wav"), selec = 1:(n + 1), start = sort(c(sample(possible_start, n), 100)))
sim_ref$end <- NA
for(i in 1:(n))
sim_ref$end[i] <- sim_ref$start[i] + round(runif(n = 1, min = 1, max = sim_ref$start[i + 1] - sim_ref$start[i] - 0.5))
sim_ref <- sim_ref[-nrow(sim_ref), ]
return(sim_ref)
})
sims <- do.call(rbind, sims_l)
return(sims)
}
run.all()
### Taxon code for macaulay ####
# downloaded from https://www.birds.cornell.edu/clementschecklist/introduction
#/updateindex/october-2025/2025-citation-checklist-downloads/
ml_taxon_code <- utils::read.csv(
"./examples/eBird_taxonomy_v2025.csv",
na.strings = ""
)
ml_taxon_code <- utils::read.csv(
"./examples/eBird_taxonomy_v2025.csv",
na.strings = ""
)
### CREATING METADATA TESTING ####
### example merged metadata ####
options(
suwo_species = "Turdus rufiventris",
suwo_format = "sound",
suwo_all_data = FALSE
)
xc_adf <- query_xenocanto()
#run document twice
if (!nzchar(Sys.getenv("xc_api_key")))
Sys.setenv(xc_api_key = getPass::getPass())
ml_taxon_code <- utils::read.csv(
"./examples/eBird_taxonomy_v2025.csv",
na.strings = ""
)
### CREATING METADATA TESTING ####
### example merged metadata ####
options(
suwo_species = "Turdus rufiventris",
suwo_format = "sound",
suwo_all_data = FALSE
)
xc_adf <- query_xenocanto()
gb_adf_s <- query_gbif()
ml_adf_s <- query_macaulay(path = tempdir())
merged_metadata <- merge_metadata(xc_adf, gb_adf_s, ml_adf_s)
### CREATE ADDITIONAL METADATA FOR TESTING ####
options(suwo_all_data = TRUE)
h_sarapiquensis <- head(
query_inaturalist(species = "Heliconia sarapiquensis", format = "image"),
4
)
h_harpyja <- head(query_wikiaves(species = "Harpia harpyja"), 4)
a_hahneli <- query_xenocanto(
species = 'sp:"Ameerega hahneli" cnt:"French Guiana" q:"A"',
api_key = Sys.getenv("xc_api_key")
)
p_lotor <- head(query_gbif(species = "Procyon lotor", format = "video"), 4)
t_rufiventris <- head(
query_macaulay(
species = "Turdus rufiventris",
format = "sound",
path = tempdir()
),
4
)
t_tricolor <- head(
query_xenocanto(
species = "Thyroptera tricolor",
api_key = Sys.getenv("xc_api_key")
),
4
)
p_striigularis <- head(
query_macaulay(
species = "Phaethornis striigularis",
format = "video",
path = tempdir()
),
4
)
d_holocanthus <- query_gbif(species = "Diodon holocanthus", format = "image")
# keep only JPEG records (for simplicity for this vignette)
d_holocanthus <- d_holocanthus[d_holocanthus$file_extension == "jpeg", ]
# select 6 random JPEG records
set.seed(666)
d_holocanthus <- d_holocanthus[sample(seq_len(nrow(d_holocanthus)), 6), ]
testing_metadata <- list(
h_harpyja = h_harpyja,
a_hahneli = a_hahneli,
p_lotor = p_lotor,
t_tricolor = t_tricolor,
t_rufiventris = t_rufiventris,
h_sarapiquensis = h_sarapiquensis,
p_striigularis = p_striigularis,
d_holocanthus = d_holocanthus
)
usethis::use_data(
ml_taxon_code,
merged_metadata,
testing_metadata,
internal = TRUE,
overwrite = TRUE
)
usethis::use_data(
ml_taxon_code,
merged_metadata,
testing_metadata,
internal = TRUE,
overwrite = TRUE,
compress = "bzip"
)
usethis::use_data(
ml_taxon_code,
merged_metadata,
testing_metadata,
internal = TRUE,
overwrite = TRUE,
compress = "gzip"
)
pkgcheck::pkgcheck(".", use_cache = FALSE)
system("R CMD check . --as-cran --resave-data=best")
system("R CMD build ./ --resave-data=best")
